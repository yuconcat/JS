<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    ul{
        background-color: #bbffaa;
    }
</style>
<body>
<ul id="ul">
    <li><a href="">超链接一</a></li>
    <li><a href="">超链接一</a></li>
    <li><a href="">超链接一</a></li>
</ul>
<button id="btn">点我添加超链接</button>
</body>
<script>
    window.onload = function () {

        //    创建新的超链接
        var ul = document.querySelector("#ul");
        var btn = document.getElementById("btn");

        btn.onclick = function () {
            var li = document.createElement("li");
            li.innerHTML="<a href=''>新超链接</a>";
            ul.appendChild(li);
        }


        //为每一个超链接绑定一个单击响应函数
        //这种遍历的方法只能为已有的超链接绑定响应函数，新建立的超链接必须要重新绑定
        // var allA = document.getElementsByTagName("a");
        // for(let i = 0;i<allA.length;i++){
        //     allA[i].onclick = function () {
        //         alert("i am A click")
        //     }
        // }


    //    希望只绑定一次事件，即可应用在多个元素上，即使元素是后添加的
    //    为ul绑定单击响应事件
    //    a -> li -> ul
        ul.onclick = function (event) {
            //target
            //  event中的target表示触发事件的对象
            //  这里event.target.nodeName返回的是a标签的大写

            alert(event.target.nodeName)
            //如果触发事件的对象是我们期望的元素，否则不执行
            //如果不进行判断，点击该行的其他地方也能触发事件
            if(event.target.nodeName == "A"){
                alert("i am ul click")
            }

        }

    //    这个就叫事件的委派：
    //          指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素
    //          从而通过祖先元素的响应函数来处理事件
    //          事件的委派利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能

    }
</script>
</html>