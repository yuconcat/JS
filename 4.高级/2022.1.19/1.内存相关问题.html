<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    //面试题：在js调用函数时传递变量参数时，是指传递还是引用传递
//    答案是：都是值传递(值和地址值)


//    var a = xxx , a内存中保存的的东西
//    xxx是基本数据，保存的就是这个数据
//    xxx是对象，保存的是对象的地址值
//    xxx是一个变量，保存的是xxx的内存内容（可以是基本数据，也可能是地址值）

//    关于引用变量的赋值问题
//    2个引用变量指向同一个对象，通过一个变量修改对象的内部数据，另一个变量看到的是修改后的数据
//    内存空间地址不变
    var obj1 = {
        name:"tom"
    }
    var obj2 = obj1
    obj1.name = "li"
    alert(obj2.name)    //li


//===========================================================================

    var a = {
        age:12
    }
    var b = a
    //这里a的内存空间：原先的地址被新的地址给覆盖了
    //但b不知道，b任然存着原来的地址
    a={
        name:"tom",
        age:21
    }
    alert("b.name "+b.name)
    alert("a.name "+a.name)
    alert("a.age "+a.age)

    function fn2(obj) {
        obj={
            age:15
        }
    }

    fn2(a);
    alert(a.age)    //这里为什么不是15，原因是：调用fn2时，做了obj = a 这件事，
                    // 所以执行函数时obj的地址指向改变了，而a不变

//============================================================================

    //问题：JS引擎如何管理内存
    //1.内存生命周期
    //      分配小内存空间，得到它的使用权
    //      存储数据，可以反复进行操作
    //      释放小内存空间
    //2.释放内存
    //      局部变量：函数执行玩自动释放
    //      对象：成为垃圾对象->垃圾回收器回收
    var x = 3;
    var objx = {};
    objx = null;    //虽然已经垃圾回收了，但是内存中还有objx，值为null，垃圾只是把堆内存的空间回收罢了

    function fn3() {
        var v = {}
    }
    fn3();         //v是自动释放，v所指的对象是在后面的某个时刻由垃圾回收器回收
</script>
</html>